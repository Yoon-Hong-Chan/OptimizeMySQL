# 3. 데이터
- 방대한 데이터량 등으로는 직접 쿼리 최적화로도 성능 향상 한계가 있음 -> 간접 쿼리 최적화 필요
### 3.1 세 가지 비밀
##### 인덱스가 도움이 되지 않을수 있다
- 좋은 인덱스라도 쿼리가 느릴수 있음
- 인덱스 조회를 한다고 해도 무한한 데이터 크기에 무한한 영향력을 제공하지는 않음
- 인덱스에 대한 믿음을 잃지 말고 인덱스가 도움이 되지 않는 상황을 알아야 함 -> 간접 쿼리 최적화로 진행
###### 인덱스 스캔
- 테이블이 커질수록 인덱스도 같이 커져서 영향력이 점점 감소
- 테이블 행수가 늘어날 수록 인덱스 전용 스캔에서 사용하는 쿼리에 대한 응답 시간도 늘어나 지연 시간 발생
###### 행 찾기
- 인덱스 조회를 사용하는 느린 쿼리를 최적화할 때, 확인하는 첫 번째 메트릭(rows)
- 좋은 인덱스를 사용하더라도 쿼리가 너무 많은 행을 검사할 수도 있음
- 매우 낮은 인덱스 선택도 인덱스 조회를 느리게하는 공범일 수 있음
- 카디널리티는 일정하게 유지되지만 행의 수가 증가하면 선택도 감소 -> 느려짐
###### 테이블 조인
- 테이블 조인할 때 각 테이블의 몇 개 행이 성능을 빠르게 떨어뜨림 -> 중첩 반복 조인
- 조인된 각 테이블에 대한 인덱스 조회를 통해 하나의 행만 일치하는 것이 가장 좋음
###### 작업 세트 크기
- 인덱스는 메모리에 있을때만 유용 -> 쿼리가 조회하는 인덱스 값이 메모리에 없으면 디스크에서 읽어옴(16kb만 메모리 저장 -> 나머지는 디스크)
- 디스크에 인덱스 조회는 느린 성능과 함께 메모리 적재를 위해 경쟁 문제 발생 -> 자주 사용하는 인덱스 값을 메모리 유지하려는 시도
- 자주 사용하는 인덱스 값과 프라미어키 행을 '작업 세트'라고 함
- 작업 세트의 크기가 사용할 수 있는 메모리보다 훨씬 커지면 인덱스에 도움이 되지 않음
- 메모리 스케일 업에도 한계가 있기 때문에 샤딩으로 해결해야함 -> 그만큼 데이터가 이미 많다고 판단
##### 데이터가 적을수록 좋다
- 성능, 관리, 비용 등 모든 면에서 데이터 크키가 적을수록 좋음
- 적절하게 필요한 양의 데이터로 최적화하고 관리하는데 시간과 노력을 기울일 가치가 있음
##### QPS가 낮을수록 좋다
###### QPS는 숫자에 불과하며 원시 처리량을 측정한 값이다
- QPS는 쿼리나 성능에 대해 질적인 정보를 제공하지 않음 -> 똑같은 QPS도 수많은 질적인 차이 존재
- QPS가 높다는 것은 쿼리 응답 시간이 좋다는 의미
###### QPS 값은 객관적인 의미가 없다
- QPS값은 애플리케이션과 관련해서만 의미가 있음
  - 평소 2,000 QPS인데 갑자기 100QPS면 애플리케이션 이상을 나타냄
  - 평소 300 QPS인데 100QPS면 정산적일 ㅅ수 있음
- QPS는 시간, 요일, 계절, 휴일등 외부 요인에도 영향을 받음
###### QPS를 높이기는 어렵다
- 애플리케이션과 관련된 최대 QPS는 스토리지 램처럼 구입할 수 없기에 늘리기 어려움\
- QPS는 낮을수록 좋음
### 3.2 최소 데이터 원칙
##### 데이터 접근
- 필요한 열만 반환

### 3.3 데이터 삭제 또는 보관

